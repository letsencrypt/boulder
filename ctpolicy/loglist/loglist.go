package loglist

import (
	_ "embed"
	"encoding/json"
	"errors"
	"fmt"
	"math/rand"
	"sync"
	"time"

	"github.com/letsencrypt/boulder/ctpolicy/ctconfig"
	"github.com/letsencrypt/boulder/ctpolicy/loglist/generated"
)

// embedded is a cached/memoized in-memory version of the autogenerated and
// embedded JSON blob. We do this so we don't have to re-parse the whole blob
// every time we want a new log list.
var embedded struct {
	sync.Once
	err error
	generated.LogListSchemaJson
}

// loadEmbedded initializes the in-memory parsed version of the embedded JSON
// log list. It should only be called inside `sync.Once.Do()`.
func loadEmbedded() {
	err := json.Unmarshal(generated.LogListJSON, &embedded)
	if err != nil {
		embedded.err = err
		return
	}
}

// LogList represents a list of logs, grouped by their operator, arranged by
// the "v3" schema as published by Chrome:
// https://www.gstatic.com/ct/log_list/v3/log_list_schema.json
// It exports no fields so that consumers don't have to deal with the terrible
// autogenerated names of the structs it wraps.
type LogList map[string]operatorGroup

// operatorGroup is a convenience type allowing constant-time lookup of logs
// within a group by their unique ID.
type operatorGroup map[string]logInfo

// logInfo is a convenience type allowing certain fields on the auto-generated
// generated.LogListSchemaJsonOperatorsElemLogsElem to be pre-parsed and stored.
type logInfo struct {
	Url            string
	Key            string
	startInclusive time.Time
	endExclusive   time.Time
}

// contains is a simple helper to see if an element is in a slice, since we
// don't have generic stdlib functions for this yet.
func contains(haystack []ctconfig.LogID, needle string) bool {
	for _, item := range haystack {
		if item.ID == needle {
			return true
		}
	}
	return false
}

// New returns a LogList which is a subset of the autogenerated and embedded
// JSON blob, containing only those logs whose LogIDs match the given list of
// IDs. If no log IDs are provided, all logs are presumed to match.
func New(ids []ctconfig.LogID) (LogList, error) {
	embedded.Do(loadEmbedded)
	if embedded.err != nil {
		return nil, fmt.Errorf("failed to parse CT Log List: %w", embedded.err)
	}

	result := make(LogList)
	for _, op := range embedded.Operators {
		group := make(operatorGroup)
		for _, log := range op.Logs {
			if log.State == nil || log.State.Usable == nil {
				continue
			}

			if len(ids) > 0 && !contains(ids, log.LogId) {
				continue
			}

			info := logInfo{
				Url: log.Url,
				Key: log.Key,
			}

			if log.TemporalInterval != nil {
				startInclusive, err := time.Parse(time.RFC3339, log.TemporalInterval.StartInclusive)
				if err != nil {
					return nil, fmt.Errorf("failed to parse log %q start timestamp: %w", log.Url, err)
				}

				endExclusive, err := time.Parse(time.RFC3339, log.TemporalInterval.EndExclusive)
				if err != nil {
					return nil, fmt.Errorf("failed to parse log %q end timestamp: %w", log.Url, err)
				}

				info.startInclusive = startInclusive
				info.endExclusive = endExclusive
			}

			group[log.LogId] = info
		}
		if len(group) > 0 {
			result[op.Name] = group
		}
	}

	if len(result) < 2 {
		return nil, errors.New("log list does not have enough groups to satisfy Chrome policy")
	}

	return result, nil
}

// OperatorForLogID returns the Name of the Group containing the Log with the
// given ID, or an error if no such log/group can be found.
func (ll LogList) OperatorForLogID(logID string) (string, error) {
	for op, group := range ll {
		_, ok := group[logID]
		if ok {
			return op, nil
		}
	}
	return "", fmt.Errorf("no log with ID %q found", logID)
}

// Permute returns the list of operator group names in a randomized order.
func (ll LogList) Permute() []string {
	keys := make([]string, 0, len(ll))
	for k := range ll {
		keys = append(keys, k)
	}

	result := make([]string, len(ll))
	for i, j := range rand.Perm(len(ll)) {
		result[i] = keys[j]
	}

	return result
}

// PickOne returns the URI and Public Key of a single randomly-selected log
// which is run by the given operator and whose temporal interval includes the
// given expiry time. It returns an error if no such log can be found.
func (ll LogList) PickOne(operator string, expiry time.Time) (string, string, error) {
	group, ok := ll[operator]
	if !ok {
		return "", "", fmt.Errorf("no log operator group named %q", operator)
	}

	candidates := make([]logInfo, 0)
	for _, log := range group {
		if log.startInclusive.IsZero() || log.endExclusive.IsZero() {
			candidates = append(candidates, log)
			continue
		}

		if (log.startInclusive.Equal(expiry) || log.startInclusive.Before(expiry)) && log.endExclusive.After(expiry) {
			candidates = append(candidates, log)
		}
	}

	if len(candidates) < 1 {
		return "", "", fmt.Errorf("no log found for group %q and expiry %s", operator, expiry)
	}

	log := candidates[rand.Intn(len(candidates))]
	return log.Url, log.Key, nil
}
