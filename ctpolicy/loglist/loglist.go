package loglist

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"sync"

	"github.com/letsencrypt/boulder/ctpolicy/loglist/generated"
)

//go:generate ./generated/update.sh

//go:embed generated/log_list.json
var logListJSON []byte

// LogList represents a list of logs, grouped by their operator, arranged by
// the "v3" schema as published by Chrome:
// https://www.gstatic.com/ct/log_list/v3/log_list_schema.json
// It exports no fields so that consumers don't have to deal with the terrible
// autogenerated names of the structs it wraps.
type LogList struct {
	sync.Mutex
	ready bool
	list  generated.LogListSchemaJson
}

// logList is a cached/memoized in-memory version of the autogenerated and
// embedded JSON blob. We do this so we don't have to re-parse the whole blob
// every time we want a new log list.
var logList LogList

// New returns a LogList built from the autogenerated and embedded JSON blob.
func New() (*LogList, error) {
	if !logList.ready {
		logList.Lock()
		defer logList.Unlock()
		err := json.Unmarshal(logListJSON, &logList.list)
		if err != nil {
			return nil, err
		}
	}
	logList.ready = true
	return &logList, nil
}

// GroupForLogID returns the Name of the Group containing the Log with the given
// ID, or an error if no such log/group can be found.
func (ll *LogList) GroupForLogID(logID string) (string, error) {
	for _, op := range ll.list.Operators {
		for _, log := range op.Logs {
			if log.LogId == logID {
				return op.Name, nil
			}
		}
	}
	return "", fmt.Errorf("no log with ID %q found", logID)
}
