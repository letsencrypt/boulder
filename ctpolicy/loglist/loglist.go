package loglist

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"math/rand"
	"sync"
	"time"

	"github.com/letsencrypt/boulder/ctpolicy/ctconfig"
	"github.com/letsencrypt/boulder/ctpolicy/loglist/generated"
)

// logList is a cached/memoized in-memory version of the autogenerated and
// embedded JSON blob. We do this so we don't have to re-parse the whole blob
// every time we want a new log list.
var logList struct {
	sync.Mutex
	ready bool
	generated.LogListSchemaJson
}

// LogList represents a list of logs, grouped by their operator, arranged by
// the "v3" schema as published by Chrome:
// https://www.gstatic.com/ct/log_list/v3/log_list_schema.json
// It exports no fields so that consumers don't have to deal with the terrible
// autogenerated names of the structs it wraps.
type LogList map[string]operatorGroup

// operatorGroup is a convenience type allowing constant-time lookup of logs
// within a group by their unique ID.
type operatorGroup map[string]*generated.LogListSchemaJsonOperatorsElemLogsElem

// New returns a LogList built from the autogenerated and embedded JSON blob.
func New() (LogList, error) {
	if !logList.ready {
		logList.Lock()
		defer logList.Unlock()

		err := json.Unmarshal(generated.LogListJSON, &logList)
		if err != nil {
			return nil, err
		}

		logList.ready = true
	}

	result := make(LogList)
	for _, op := range logList.Operators {
		group := make(operatorGroup)
		for i := range op.Logs {
			log := op.Logs[i]
			group[log.LogId] = &log
		}
		result[op.Name] = group
	}

	return result, nil
}

// NewFromLogIDs returns a LogList which is a subset of the autogenerated and
// embedded JSON blob, containing only those logs whose LogIDs match the given
// list of IDs.
func NewFromLogIDs(ids []ctconfig.LogID) (LogList, error) {
	if !logList.ready {
		logList.Lock()
		defer logList.Unlock()

		err := json.Unmarshal(generated.LogListJSON, &logList)
		if err != nil {
			return nil, err
		}

		logList.ready = true
	}

	fmt.Printf("Loading log list with IDs: %v\n", ids)

	result := make(LogList)
	for _, op := range logList.Operators {
		group := make(operatorGroup)
		for i := range op.Logs {
			log := op.Logs[i]
			for _, id := range ids {
				if log.LogId == id.ID && *log.Description == id.Name {
					group[log.LogId] = &log
					break
				}
			}
		}
		if len(group) > 0 {
			result[op.Name] = group
		}
	}

	return result, nil
}

// OperatorForLogID returns the Name of the Group containing the Log with the
// given ID, or an error if no such log/group can be found.
func (ll LogList) OperatorForLogID(logID string) (string, error) {
	for op, group := range ll {
		_, ok := group[logID]
		if ok {
			return op, nil
		}
	}
	return "", fmt.Errorf("no log with ID %q found", logID)
}

// Permute returns the list of operator group names in a randomized order.
func (ll LogList) Permute() []string {
	keys := make([]string, 0, len(ll))
	for k := range ll {
		keys = append(keys, k)
	}

	result := make([]string, len(ll))
	for i, j := range rand.Perm(len(ll)) {
		result[i] = keys[j]
	}

	return result
}

// PickOne returns the URI and Public Key of a single randomly-selected log
// which is run by the given operator and whose temporal interval includes the
// given expiry time. It returns an error if no such log can be found.
func (ll LogList) PickOne(operator string, expiry time.Time) (string, string, error) {
	group, ok := ll[operator]
	if !ok {
		return "", "", fmt.Errorf("no log operator group named %q", operator)
	}

	candidates := make([]*generated.LogListSchemaJsonOperatorsElemLogsElem, 0)
	for _, log := range group {
		if log.TemporalInterval == nil {
			candidates = append(candidates, log)
			continue
		}

		end, err := time.Parse(time.RFC3339, log.TemporalInterval.EndExclusive)
		if err != nil {
			continue
		}

		start, err := time.Parse(time.RFC3339, log.TemporalInterval.StartInclusive)
		if err != nil {
			continue
		}

		if (start.Equal(expiry) || start.Before(expiry)) && end.After(expiry) {
			candidates = append(candidates, log)
		}
	}

	if len(candidates) < 1 {
		return "", "", fmt.Errorf("no log found for group %q and expiry %s", operator, expiry)
	}

	log := candidates[rand.Intn(len(candidates))]
	return log.Url, log.Key, nil
}
