package ca

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"errors"
	"fmt"
	"math/big"
	"os"
	"strings"
	"testing"
	"time"

	ct "github.com/google/certificate-transparency-go"
	cttls "github.com/google/certificate-transparency-go/tls"
	ctx509 "github.com/google/certificate-transparency-go/x509"
	"github.com/jmhodges/clock"
	"github.com/miekg/pkcs11"
	"github.com/prometheus/client_golang/prometheus"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/types/known/emptypb"

	capb "github.com/letsencrypt/boulder/ca/proto"
	"github.com/letsencrypt/boulder/config"
	"github.com/letsencrypt/boulder/core"
	corepb "github.com/letsencrypt/boulder/core/proto"
	berrors "github.com/letsencrypt/boulder/errors"
	"github.com/letsencrypt/boulder/features"
	"github.com/letsencrypt/boulder/goodkey"
	"github.com/letsencrypt/boulder/identifier"
	"github.com/letsencrypt/boulder/issuance"
	blog "github.com/letsencrypt/boulder/log"
	"github.com/letsencrypt/boulder/must"
	"github.com/letsencrypt/boulder/policy"
	rapb "github.com/letsencrypt/boulder/ra/proto"
	sapb "github.com/letsencrypt/boulder/sa/proto"
	"github.com/letsencrypt/boulder/test"
)

var (
	// * Random public key
	// * CN = not-example.com
	// * DNSNames = not-example.com, www.not-example.com
	CNandSANCSR = mustRead("./testdata/cn_and_san.der.csr")

	// CSR generated by Go:
	// * Random public key
	// * CN = not-example.com
	// * Includes an extensionRequest attribute for a well-formed TLS Feature extension
	MustStapleCSR = mustRead("./testdata/must_staple.der.csr")

	// CSR generated by Go:
	// * Random public key
	// * CN = not-example.com
	// * Includes an extensionRequest attribute for an unknown extension with an
	//   empty value. That extension's OID, 2.25.123456789, is on the UUID arc.
	//   It isn't a real randomly-generated UUID because Go represents the
	//   components of the OID as 32-bit integers, which aren't large enough to
	//   hold a real 128-bit UUID; this doesn't matter as far as what we're
	//   testing here is concerned.
	UnsupportedExtensionCSR = mustRead("./testdata/unsupported_extension.der.csr")

	// CSR generated by Go:
	// * Random public key
	// * CN = not-example.com
	// * Includes an extensionRequest attribute for the CT poison extension
	//   with a valid NULL value.
	CTPoisonExtensionCSR = mustRead("./testdata/ct_poison_extension.der.csr")

	// CSR generated by Go:
	// * Random public key
	// * CN = not-example.com
	// * Includes an extensionRequest attribute for the CT poison extension
	//   with an invalid empty value.
	CTPoisonExtensionEmptyCSR = mustRead("./testdata/ct_poison_extension_empty.der.csr")

	// CSR generated by Go:
	// * Random ECDSA public key.
	// * CN = [none]
	// * DNSNames = example.com, example2.com
	ECDSACSR = mustRead("./testdata/ecdsa.der.csr")

	// OIDExtensionCTPoison is defined in RFC 6962 s3.1.
	OIDExtensionCTPoison = asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 11129, 2, 4, 3}

	// OIDExtensionSCTList is defined in RFC 6962 s3.3.
	OIDExtensionSCTList = asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 11129, 2, 4, 2}
)

func mustRead(path string) []byte {
	return must.Do(os.ReadFile(path))
}

// caArgs is a container for all of the arguments to
// NewCertificateAuthorityImpl. It exists so that tests can easily build a
// default certificateAuthorityImpl, but can also easily customize that object
// to exercise various behaviors. The expected usage flow is:
//
//	cargs := newTestCA(t)
//	cargs.foo = someOverride
//	ca := cargs.make()
//
// Its fields should remain identical to the NewCertificateAuthorityImpl args.
type caArgs struct {
	sa             sapb.StorageAuthorityCertificateClient
	sctService     rapb.SCTProviderClient
	pa             core.PolicyAuthority
	boulderIssuers []*issuance.Issuer
	certProfiles   map[string]*issuance.ProfileConfig
	serialPrefix   byte
	maxNames       int
	keyPolicy      goodkey.KeyPolicy
	logger         *blog.Mock
	metrics        *caMetrics
	clk            clock.FakeClock
}

// newCAArgs returns a caArgs populated with reasonable default values for testing.
func newCAArgs(t *testing.T) *caArgs {
	features.Reset()

	fc := clock.NewFake()
	fc.Add(1 * time.Hour)

	pa, err := policy.New(map[identifier.IdentifierType]bool{"dns": true}, nil, blog.NewMock())
	test.AssertNotError(t, err, "Couldn't create PA")
	err = pa.LoadIdentPolicyFile("../test/ident-policy.yaml")
	test.AssertNotError(t, err, "Couldn't set identifier policy")

	certProfiles := make(map[string]*issuance.ProfileConfig, 0)
	certProfiles["legacy"] = &issuance.ProfileConfig{
		IncludeCRLDistributionPoints: true,
		MaxValidityPeriod:            config.Duration{Duration: time.Hour * 24 * 90},
		MaxValidityBackdate:          config.Duration{Duration: time.Hour},
		IgnoredLints:                 []string{"w_subject_common_name_included"},
	}
	certProfiles["modern"] = &issuance.ProfileConfig{
		OmitCommonName:               true,
		OmitKeyEncipherment:          true,
		OmitClientAuth:               true,
		OmitSKID:                     true,
		IncludeCRLDistributionPoints: true,
		MaxValidityPeriod:            config.Duration{Duration: time.Hour * 24 * 6},
		MaxValidityBackdate:          config.Duration{Duration: time.Hour},
		IgnoredLints:                 []string{"w_ext_subject_key_identifier_missing_sub_cert"},
	}
	test.AssertEquals(t, len(certProfiles), 2)

	boulderIssuers := make([]*issuance.Issuer, 4)
	for i, name := range []string{"int-r3", "int-r4", "int-e1", "int-e2"} {
		boulderIssuers[i], err = issuance.LoadIssuer(issuance.IssuerConfig{
			Active:     true,
			IssuerURL:  fmt.Sprintf("http://not-example.com/i/%s", name),
			OCSPURL:    "http://not-example.com/o",
			CRLURLBase: fmt.Sprintf("http://not-example.com/c/%s/", name),
			CRLShards:  10,
			Location: issuance.IssuerLoc{
				File:     fmt.Sprintf("../test/hierarchy/%s.key.pem", name),
				CertFile: fmt.Sprintf("../test/hierarchy/%s.cert.pem", name),
			},
		}, fc)
		test.AssertNotError(t, err, "Couldn't load test issuer")
	}

	keyPolicy, err := goodkey.NewPolicy(nil, nil)
	test.AssertNotError(t, err, "Failed to create test keypolicy")

	signatureCount := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "signatures",
			Help: "Number of signatures",
		},
		[]string{"purpose", "issuer"})
	signErrorCount := prometheus.NewCounterVec(prometheus.CounterOpts{
		Name: "signature_errors",
		Help: "A counter of signature errors labelled by error type",
	}, []string{"type"})
	lintErrorCount := prometheus.NewCounter(
		prometheus.CounterOpts{
			Name: "lint_errors",
			Help: "Number of issuances that were halted by linting errors",
		})
	certificatesCount := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "certificates",
			Help: "Number of certificates issued",
		}, []string{"profile"})
	cametrics := &caMetrics{signatureCount, signErrorCount, lintErrorCount, certificatesCount}

	return &caArgs{
		sa:             &mockSA{},
		sctService:     &mockSCTService{},
		pa:             pa,
		boulderIssuers: boulderIssuers,
		certProfiles:   certProfiles,
		serialPrefix:   0x11,
		maxNames:       2,
		keyPolicy:      keyPolicy,
		logger:         blog.NewMock(),
		metrics:        cametrics,
		clk:            fc,
	}
}

// make passes all of the caArgs' fields to the NewCertificateAuthorityImpl
// constructor and returns the result.
func (c *caArgs) make() (*certificateAuthorityImpl, error) {
	return NewCertificateAuthorityImpl(
		c.sa, c.sctService, c.pa, c.boulderIssuers, c.certProfiles, c.serialPrefix,
		c.maxNames, c.keyPolicy, c.logger, c.metrics, c.clk)
}

type mockSA struct{}

func (m *mockSA) AddSerial(ctx context.Context, req *sapb.AddSerialRequest, _ ...grpc.CallOption) (*emptypb.Empty, error) {
	return &emptypb.Empty{}, nil
}

func (m *mockSA) AddPrecertificate(ctx context.Context, req *sapb.AddCertificateRequest, _ ...grpc.CallOption) (*emptypb.Empty, error) {
	return &emptypb.Empty{}, nil
}

func (m *mockSA) AddCertificate(ctx context.Context, req *sapb.AddCertificateRequest, _ ...grpc.CallOption) (*emptypb.Empty, error) {
	return &emptypb.Empty{}, nil
}

func (m *mockSA) GetCertificate(ctx context.Context, req *sapb.Serial, _ ...grpc.CallOption) (*corepb.Certificate, error) {
	return nil, berrors.NotFoundError("cannot find the cert")
}

func (m *mockSA) GetLintPrecertificate(ctx context.Context, req *sapb.Serial, _ ...grpc.CallOption) (*corepb.Certificate, error) {
	return nil, berrors.NotFoundError("cannot find the precert")
}

type mockSCTService struct{}

func (m mockSCTService) GetSCTs(ctx context.Context, sctRequest *rapb.SCTRequest, _ ...grpc.CallOption) (*rapb.SCTResponse, error) {
	sct := ct.SignedCertificateTimestamp{
		SCTVersion: 0,
		Timestamp:  2020,
		Signature: ct.DigitallySigned{
			Signature: []byte{0},
		},
	}

	sctBytes, err := cttls.Marshal(sct)
	if err != nil {
		return nil, err
	}

	return &rapb.SCTResponse{SctDER: [][]byte{sctBytes}}, nil
}

func TestNewCertificateAuthorityImpl_BadSerialPrefix(t *testing.T) {
	t.Parallel()
	cargs := newCAArgs(t)

	cargs.serialPrefix = 0x00
	_, err := cargs.make()
	if err == nil {
		t.Errorf("NewCertificateAuthorityImpl(serialPrefix=0x00) succeeded, but want error")
	}

	cargs.serialPrefix = 0x80
	_, err = cargs.make()
	if err == nil {
		t.Errorf("NewCertificateAuthorityImpl(serialPrefix=0x80) succeeded, but want error")
	}
}

func TestNewCertificateAuthorityImpl_InsufficientIssuers(t *testing.T) {
	t.Parallel()
	cargs := newCAArgs(t)
	origIssuers := cargs.boulderIssuers

	for _, tc := range []struct {
		name    string
		issuers []*issuance.Issuer
		wantErr string
	}{
		{
			name:    "no issuers",
			issuers: nil,
			wantErr: "at least one issuer",
		},
		{
			name:    "ecdsa only",
			issuers: origIssuers[2:],
			wantErr: "no RSA issuers configured",
		},
		{
			name:    "rsa only",
			issuers: origIssuers[:2],
			wantErr: "no ECDSA issuers configured",
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			cargs.boulderIssuers = tc.issuers
			_, err := cargs.make()
			if err == nil {
				t.Fatalf("NewCertificateAuthorityImpl(%s) succeeded, but want error", tc.name)
			}

			if !strings.Contains(err.Error(), tc.wantErr) {
				t.Fatalf("NewCertificateAuthorityImpl(%s) = %q, but want %q", tc.name, err, tc.wantErr)
			}
		})
	}
}

func TestNewCertificateAuthorityImpl_InsufficientProfiles(t *testing.T) {
	t.Parallel()
	cargs := newCAArgs(t)
	cargs.certProfiles = nil

	_, err := cargs.make()
	if err == nil {
		t.Fatalf("NewCertificateAuthorityImpl(certificateProfiles=nil) succeeded, but want error")
	}

	wantErr := "at least one certificate profile"
	if !strings.Contains(err.Error(), wantErr) {
		t.Fatalf("NewCertificateAuthorityImpl(certificateProfiles=nil) = %q, but want %q", err, wantErr)
	}
}

// recordingSA keeps track of the serial, precertificate, and certificate which
// are written to it. We use recordingSA only for the _HappyPath test because
// it's a pain to mitigate the data-races inherent in writing to it from many
// parallel subtests.
type recordingSA struct {
	serial         *sapb.AddSerialRequest
	precertificate *sapb.AddCertificateRequest
	certificate    *sapb.AddCertificateRequest
}

func (m *recordingSA) AddSerial(ctx context.Context, req *sapb.AddSerialRequest, _ ...grpc.CallOption) (*emptypb.Empty, error) {
	m.serial = req
	return &emptypb.Empty{}, nil
}

func (m *recordingSA) AddPrecertificate(ctx context.Context, req *sapb.AddCertificateRequest, _ ...grpc.CallOption) (*emptypb.Empty, error) {
	m.precertificate = req
	return &emptypb.Empty{}, nil
}

func (m *recordingSA) AddCertificate(ctx context.Context, req *sapb.AddCertificateRequest, _ ...grpc.CallOption) (*emptypb.Empty, error) {
	m.certificate = req
	return &emptypb.Empty{}, nil
}

func (m *recordingSA) GetCertificate(ctx context.Context, req *sapb.Serial, _ ...grpc.CallOption) (*corepb.Certificate, error) {
	return nil, berrors.NotFoundError("cannot find the cert")
}

func (m *recordingSA) GetLintPrecertificate(ctx context.Context, req *sapb.Serial, _ ...grpc.CallOption) (*corepb.Certificate, error) {
	return nil, berrors.NotFoundError("cannot find the precert")
}

func findExtension(extensions []pkix.Extension, id asn1.ObjectIdentifier) *pkix.Extension {
	for _, ext := range extensions {
		if ext.Id.Equal(id) {
			return &ext
		}
	}
	return nil
}

// deserializeSCTList deserializes a list of SCTs.
// Forked from github.com/cloudflare/cfssl/helpers
func deserializeSCTList(sctListExtensionValue []byte) ([]ct.SignedCertificateTimestamp, error) {
	var serializedSCTList []byte
	_, err := asn1.Unmarshal(sctListExtensionValue, &serializedSCTList)
	if err != nil {
		return nil, err
	}

	var sctList ctx509.SignedCertificateTimestampList
	rest, err := cttls.Unmarshal(serializedSCTList, &sctList)
	if err != nil {
		return nil, err
	}
	if len(rest) != 0 {
		return nil, errors.New("serialized SCT list contained trailing garbage")
	}
	list := make([]ct.SignedCertificateTimestamp, len(sctList.SCTList))
	for i, serializedSCT := range sctList.SCTList {
		var sct ct.SignedCertificateTimestamp
		rest, err := cttls.Unmarshal(serializedSCT.Val, &sct)
		if err != nil {
			return nil, err
		}
		if len(rest) != 0 {
			return nil, errors.New("serialized SCT contained trailing garbage")
		}
		list[i] = sct
	}
	return list, nil
}

func TestIssueCertificate_HappyPath(t *testing.T) {
	for _, profile := range []string{"legacy", "modern"} {
		for _, tc := range []struct {
			name string
			csr  []byte
		}{
			{
				name: "RSA",
				csr:  CNandSANCSR,
			},
			{
				name: "ECDSA",
				csr:  ECDSACSR,
			},
			{
				name: "unrecognized extension",
				csr:  UnsupportedExtensionCSR,
			},
			{
				name: "poison extension",
				csr:  CTPoisonExtensionCSR,
			},
			{
				name: "malformed poison extension",
				csr:  CTPoisonExtensionEmptyCSR,
			},
			{
				// Rejection of CSRs that request Must-Staple happens in the RA.
				name: "must staple extension",
				csr:  mustRead("./testdata/must_staple.der.csr"),
			},
		} {
			t.Run(tc.name+"/"+profile, func(t *testing.T) {
				t.Parallel()

				// Use our own CA for each of these parallel subtests, because we plan
				// to inspect the serial, precert, and final cert stored in the mock SA.
				// Also so we can assert that certain metrics have specific values.
				cargs := newCAArgs(t)
				sa := &recordingSA{}
				cargs.sa = sa
				ca, err := cargs.make()
				if err != nil {
					t.Fatalf("making test ca: %s", err)
				}

				res, err := ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
					RegistrationID: 1, OrderID: 1,
					Csr: tc.csr, CertProfileName: profile,
				})
				if err != nil {
					t.Fatalf("IssueCertificate(%s) = %q, but want success", tc.name, err)
				}

				test.AssertMetricWithLabelsEquals(t, ca.metrics.signatureCount, prometheus.Labels{"purpose": "precertificate", "status": "success"}, 1)
				test.AssertMetricWithLabelsEquals(t, ca.metrics.signatureCount, prometheus.Labels{"purpose": "certificate", "status": "success"}, 1)

				if sa.serial.RegID != 1 {
					t.Errorf("want serial to be associated with acct %d, but got %d", 1, sa.serial.RegID)
				}

				storedPrecert, err := x509.ParseCertificate(sa.precertificate.Der)
				if err != nil {
					t.Fatalf("parsing precert: %s", err)
				}

				poisonExtension := findExtension(storedPrecert.Extensions, OIDExtensionCTPoison)
				if poisonExtension == nil {
					t.Fatal("failed to find ctpoison extension")
				}

				if !poisonExtension.Critical {
					t.Error("precertificate ctpoison extension must be critical")
				}

				if !bytes.Equal(poisonExtension.Value, []byte{0x05, 0x00}) { // ASN.1 DER NULL
					t.Errorf("precertificate poison extension has value %x, but want %x", poisonExtension.Value, []byte{0x05, 0x00})
				}

				storedCert, err := x509.ParseCertificate(sa.certificate.Der)
				if err != nil {
					t.Fatalf("parsing cert: %s", err)
				}

				sctExtension := findExtension(storedCert.Extensions, OIDExtensionSCTList)
				if sctExtension == nil {
					t.Fatal("failed to find sctList extension")
				}

				if sctExtension.Critical {
					t.Error("sctList extension must not be critical")
				}

				sctList, err := deserializeSCTList(sctExtension.Value)
				if err != nil {
					t.Fatalf("parsing sctList extension: %s", err)
				}

				if len(sctList) != 1 {
					t.Errorf("got %d SCTs, but want 1", len(sctList))
				}

				cert, err := x509.ParseCertificate(res.DER)
				if err != nil {
					t.Fatalf("parsing returned cert: %s", err)
				}

				if (sa.serial.Serial != core.SerialToString(storedPrecert.SerialNumber)) ||
					(sa.serial.Serial != core.SerialToString(storedCert.SerialNumber)) ||
					(sa.serial.Serial != core.SerialToString(cert.SerialNumber)) {
					t.Errorf("expected all serials to match")
				}

				if !bytes.Equal(res.DER, sa.certificate.Der) {
					t.Errorf("Expected stored and returned cert to be identical")
				}
			})
		}
	}
}

func TestIssueCertificate_BadCSR(t *testing.T) {
	t.Parallel()

	ca, err := newCAArgs(t).make()
	if err != nil {
		t.Fatalf("making test ca: %s", err)
	}

	for _, tc := range []struct {
		name    string
		csrPath string
	}{
		{
			name:    "no names",
			csrPath: "./testdata/no_names.der.csr",
		},
		{
			name:    "too many names",
			csrPath: "./testdata/too_many_names.der.csr",
		},
		{
			name:    "short key",
			csrPath: "./testdata/short_key.der.csr",
		},
		{
			name:    "bad key algorithm",
			csrPath: "./testdata/bad_algorithm.der.csr",
		},
		{
			name:    "invalid signature",
			csrPath: "./testdata/invalid_signature.der.csr",
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			_, err := ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
				RegistrationID: 1, OrderID: 1,
				Csr: mustRead(tc.csrPath), CertProfileName: "legacy",
			})
			if err == nil {
				t.Fatalf("IssueCertificate(%q) succeeded, but want error", tc.csrPath)
			}
			if !errors.Is(err, berrors.BadCSR) {
				t.Fatalf("IssueCertificate(%q) = %T, but want %T", tc.csrPath, err, berrors.BadCSR)
			}
		})
	}
}

func TestIssueCertificate_ValidPastIssuer(t *testing.T) {
	t.Parallel()
	cargs := newCAArgs(t)

	// Limit ourselves to only having one ECDSA issuer, just in case they have
	// different notAfter dates.
	cargs.boulderIssuers = cargs.boulderIssuers[:3]

	// Jump to a time just moments before the test issuer expire.
	future := cargs.boulderIssuers[2].Cert.Certificate.NotAfter.Add(-1 * time.Hour)
	cargs.clk.Set(future)

	ca, err := cargs.make()
	if err != nil {
		t.Fatalf("making test ca: %s", err)
	}

	_, err = ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
		RegistrationID: 1, OrderID: 1,
		Csr: ECDSACSR, CertProfileName: "legacy",
	})
	if err == nil {
		t.Fatalf("IssueCertificate(notAfter > issuer.notAfter) succeeded, but want error")
	}
	if !errors.Is(err, berrors.InternalServer) {
		t.Fatalf("IssueCertificate(notAfter > issuer.notAfter) = %T, but want %T", err, berrors.InternalServer)
	}
}

func TestIssueCertificate_InvalidProfile(t *testing.T) {
	t.Parallel()

	ca, err := newCAArgs(t).make()
	if err != nil {
		t.Fatalf("making test ca: %s", err)
	}

	for _, tc := range []struct {
		name    string
		profile string
		wantErr string
	}{
		{
			name:    "no profile",
			profile: "",
			wantErr: "Incomplete issue certificate request",
		},
		{
			name:    "unrecognized profile",
			profile: "doesnotexist",
			wantErr: "incapable of using a profile named",
		},
		{
			name:    "invalid profile name",
			profile: "🤓",
			wantErr: "incapable of using a profile named",
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			_, err := ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
				RegistrationID: 1, OrderID: 1,
				Csr: ECDSACSR, CertProfileName: tc.profile,
			})
			if err == nil {
				t.Fatalf("IssueCertificate(profile=%q) succeeded, but want error", tc.profile)
			}
			if !strings.Contains(err.Error(), tc.wantErr) {
				t.Fatalf("IssueCertificate(profile=%q) = %q, but want %q", tc.profile, err, tc.wantErr)
			}
		})
	}
}

func TestIssueCertificate_ProfileSelection(t *testing.T) {
	t.Parallel()

	ca, err := newCAArgs(t).make()
	if err != nil {
		t.Fatalf("making test ca: %s", err)
	}

	for _, tc := range []struct {
		profile      string
		wantValidity time.Duration
	}{
		{
			profile:      "legacy",
			wantValidity: 90 * 24 * time.Hour,
		},
		{
			profile:      "modern",
			wantValidity: 6 * 24 * time.Hour,
		},
	} {
		t.Run(tc.profile, func(t *testing.T) {
			t.Parallel()

			res, err := ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
				RegistrationID: 1, OrderID: 1,
				Csr: ECDSACSR, CertProfileName: tc.profile,
			})
			if err != nil {
				t.Fatalf("IssueCertificate(profile=%q) = %q, but want success", tc.profile, err)
			}

			cert, err := x509.ParseCertificate(res.DER)
			if err != nil {
				t.Fatalf("parsing certificate: %s", err)
			}

			// We use the validity period as a proxy for detecting whether the correct
			// profile was selected and used, since we know that the validity period
			// differs between the two test profiles.
			validity := cert.NotAfter.Add(time.Second).Sub(cert.NotBefore)
			if validity != tc.wantValidity {
				t.Errorf("IssueCertificate(profile=%q) = validity %d, but want %d", tc.profile, validity, tc.wantValidity)
			}
		})
	}
}

func TestIssueCertificate_IssuerSelection(t *testing.T) {
	t.Parallel()
	cargs := newCAArgs(t)
	origIssuers := cargs.boulderIssuers

	ca, err := cargs.make()
	if err != nil {
		t.Fatalf("making test ca: %s", err)
	}

	for _, tc := range []struct {
		name        string
		csr         []byte
		wantIssuers []*issuance.Issuer
		wantKUs     x509.KeyUsage
	}{
		{
			name:        "ECDSA",
			csr:         ECDSACSR,
			wantIssuers: origIssuers[2:],
			wantKUs:     x509.KeyUsageDigitalSignature,
		},
		{
			name:        "RSA",
			csr:         CNandSANCSR,
			wantIssuers: origIssuers[:2],
			wantKUs:     x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			res, err := ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
				RegistrationID: 1, OrderID: 1,
				Csr: tc.csr, CertProfileName: "legacy",
			})
			if err != nil {
				t.Fatalf("IssueCertificate(csr=%q) = %q, but want success", tc.name, err)
			}

			cert, err := x509.ParseCertificate(res.DER)
			if err != nil {
				t.Fatalf("parsing certificate: %s", err)
			}

			if cert.KeyUsage != tc.wantKUs {
				t.Errorf("IssueCertificate(csr=%q) has KU %v, but want %v", tc.name, cert.KeyUsage, tc.wantKUs)
			}

			validated := false
			for _, issuer := range tc.wantIssuers {
				err = cert.CheckSignatureFrom(issuer.Cert.Certificate)
				if err == nil {
					validated = true
					break
				}
			}
			if !validated {
				t.Errorf("IssueCertificate(csr=%q) issued from unexpected issuer %q", tc.name, cert.Issuer.CommonName)
			}
		})
	}
}

func TestIssueCertificate_UnpredictableIssuance(t *testing.T) {
	cargs := newCAArgs(t)

	// Load our own set of issuer configs, specifically with:
	// - 3 issuers,
	// - 2 of which are active
	boulderIssuers := make([]*issuance.Issuer, 3)
	var err error
	for i, name := range []string{"int-e1", "int-e2", "int-r3"} {
		boulderIssuers[i], err = issuance.LoadIssuer(issuance.IssuerConfig{
			Active:     i != 0, // Make one of the ECDSA issuers inactive.
			IssuerURL:  fmt.Sprintf("http://not-example.com/i/%s", name),
			OCSPURL:    "http://not-example.com/o",
			CRLURLBase: fmt.Sprintf("http://not-example.com/c/%s/", name),
			CRLShards:  10,
			Location: issuance.IssuerLoc{
				File:     fmt.Sprintf("../test/hierarchy/%s.key.pem", name),
				CertFile: fmt.Sprintf("../test/hierarchy/%s.cert.pem", name),
			},
		}, cargs.clk)
		test.AssertNotError(t, err, "Couldn't load test issuer")
	}
	cargs.boulderIssuers = boulderIssuers

	ca, err := cargs.make()
	if err != nil {
		t.Fatalf("making test ca: %s", err)
	}

	// Then, modify the resulting issuer maps so that the RSA issuer appears to
	// be an ECDSA issuer. This would be easier if we had three ECDSA issuers to
	// use here, but that doesn't exist in //test/hierarchy (yet).
	ca.issuers.byAlg[x509.ECDSA] = append(ca.issuers.byAlg[x509.ECDSA], ca.issuers.byAlg[x509.RSA]...)
	ca.issuers.byAlg[x509.RSA] = []*issuance.Issuer{}

	// Issue the same (ECDSA-keyed) certificate 20 times. None of the issuances
	// should come from the inactive issuer (int-e1). At least one issuance should
	// come from each of the two active issuers (int-e2 and int-r3). With 20
	// trials, the probability that all 20 issuances come from the same issuer is
	// 0.5 ^ 20 = 9.5e-7 ~= 1e-6 = 1 in a million, so we do not consider this test
	// to be flaky.
	seenE2 := false
	seenR3 := false
	for range 20 {
		res, err := ca.IssueCertificate(t.Context(), &capb.IssueCertificateRequest{
			RegistrationID: 1, OrderID: 1,
			Csr: ECDSACSR, CertProfileName: "legacy",
		})
		if err != nil {
			t.Fatalf("issuing certificate: %s", err)
		}

		cert, err := x509.ParseCertificate(res.DER)
		if err != nil {
			t.Fatalf("parsing certificate: %s", err)
		}

		if strings.Contains(cert.Issuer.CommonName, "E1") {
			t.Fatal("Issued certificate from inactive issuer")
		} else if strings.Contains(cert.Issuer.CommonName, "E2") {
			seenE2 = true
		} else if strings.Contains(cert.Issuer.CommonName, "R3") {
			seenR3 = true
		}
	}

	if !seenE2 {
		t.Error("Expected at least one issuance from active issuer E2")
	}
	if !seenR3 {
		t.Error("Expected at least one issuance from active issuer R3")
	}
}

func TestMakeCertificateProfilesMap(t *testing.T) {
	t.Parallel()
	cargs := newCAArgs(t)
	test.AssertEquals(t, len(cargs.certProfiles), 2)

	testCases := []struct {
		name              string
		profileConfigs    map[string]*issuance.ProfileConfig
		expectedErrSubstr string
		expectedProfiles  []string
	}{
		{
			name:              "nil profile map",
			profileConfigs:    nil,
			expectedErrSubstr: "at least one certificate profile",
		},
		{
			name:              "no profiles",
			profileConfigs:    map[string]*issuance.ProfileConfig{},
			expectedErrSubstr: "at least one certificate profile",
		},
		{
			name: "empty profile config",
			profileConfigs: map[string]*issuance.ProfileConfig{
				"empty": {},
			},
			expectedErrSubstr: "at least one revocation mechanism must be included",
		},
		{
			name: "minimal profile config",
			profileConfigs: map[string]*issuance.ProfileConfig{
				"empty": {IncludeCRLDistributionPoints: true},
			},
			expectedProfiles: []string{"empty"},
		},
		{
			name:             "default profiles from setup func",
			profileConfigs:   cargs.certProfiles,
			expectedProfiles: []string{"legacy", "modern"},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			profiles, err := makeCertificateProfilesMap(tc.profileConfigs)

			if tc.expectedErrSubstr != "" {
				test.AssertError(t, err, "profile construction should have failed")
				test.AssertContains(t, err.Error(), tc.expectedErrSubstr)
			} else {
				test.AssertNotError(t, err, "profile construction should have succeeded")
			}

			if tc.expectedProfiles != nil {
				test.AssertEquals(t, len(profiles), len(tc.expectedProfiles))
			}

			for _, expected := range tc.expectedProfiles {
				_, ok := profiles[expected]
				test.Assert(t, ok, fmt.Sprintf("expected profile %q not found", expected))
			}
		})
	}
}

func TestNoteSignError(t *testing.T) {
	testCtx := newCAArgs(t)
	metrics := testCtx.metrics

	err := fmt.Errorf("wrapped non-signing error: %w", errors.New("oops"))
	metrics.noteSignError(err)
	test.AssertMetricWithLabelsEquals(t, metrics.signErrorCount, prometheus.Labels{"type": "HSM"}, 0)

	err = fmt.Errorf("wrapped signing error: %w", pkcs11.Error(5))
	metrics.noteSignError(err)
	test.AssertMetricWithLabelsEquals(t, metrics.signErrorCount, prometheus.Labels{"type": "HSM"}, 1)
}

func TestGenerateSKID(t *testing.T) {
	t.Parallel()
	key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	test.AssertNotError(t, err, "Error generating key")

	sha256skid, err := generateSKID(key.Public())
	test.AssertNotError(t, err, "Error generating SKID")
	test.AssertEquals(t, len(sha256skid), 20)
	test.AssertEquals(t, cap(sha256skid), 20)
	features.Reset()
}

func TestVerifyTBSCertIsDeterministic(t *testing.T) {
	t.Parallel()

	// Create first keypair and cert
	testKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	test.AssertNotError(t, err, "unable to generate ECDSA private key")
	template := &x509.Certificate{
		NotAfter:     time.Now().Add(1 * time.Hour),
		DNSNames:     []string{"example.com"},
		SerialNumber: big.NewInt(1),
	}
	certDer1, err := x509.CreateCertificate(rand.Reader, template, template, &testKey.PublicKey, testKey)
	test.AssertNotError(t, err, "unable to create certificate")

	// Create second keypair and cert
	testKey2, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	test.AssertNotError(t, err, "unable to generate ECDSA private key")
	template2 := &x509.Certificate{
		NotAfter:     time.Now().Add(2 * time.Hour),
		DNSNames:     []string{"example.net"},
		SerialNumber: big.NewInt(2),
	}
	certDer2, err := x509.CreateCertificate(rand.Reader, template2, template2, &testKey2.PublicKey, testKey2)
	test.AssertNotError(t, err, "unable to create certificate")

	testCases := []struct {
		name          string
		lintCertBytes []byte
		leafCertBytes []byte
		errorSubstr   string
	}{
		{
			name:          "Both nil",
			lintCertBytes: nil,
			leafCertBytes: nil,
			errorSubstr:   "were nil",
		},
		{
			name:          "Missing a value, invalid input",
			lintCertBytes: nil,
			leafCertBytes: []byte{0x6, 0x6, 0x6},
			errorSubstr:   "were nil",
		},
		{
			name:          "Missing a value, valid input",
			lintCertBytes: nil,
			leafCertBytes: certDer1,
			errorSubstr:   "were nil",
		},
		{
			name:          "Mismatched bytes, invalid input",
			lintCertBytes: []byte{0x6, 0x6, 0x6},
			leafCertBytes: []byte{0x1, 0x2, 0x3},
			errorSubstr:   "malformed certificate",
		},
		{
			name:          "Mismatched bytes, invalider input",
			lintCertBytes: certDer1,
			leafCertBytes: []byte{0x1, 0x2, 0x3},
			errorSubstr:   "malformed certificate",
		},
		{
			// This case is an example of when a linting cert's DER bytes are
			// mismatched compared to then precert or final cert created from
			// that linting cert's DER bytes.
			name:          "Mismatched bytes, valid input",
			lintCertBytes: certDer1,
			leafCertBytes: certDer2,
			errorSubstr:   "mismatch between",
		},
		{
			// Take this with a grain of salt since this test is not actually
			// creating a linting certificate and performing two
			// x509.CreateCertificate() calls like
			// ca.IssueCertificateForPrecertificate and
			// ca.issuePrecertificateInner do. However, we're still going to
			// verify the equality.
			name:          "Valid",
			lintCertBytes: certDer1,
			leafCertBytes: certDer1,
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.name, func(t *testing.T) {
			t.Parallel()
			err := tbsCertIsDeterministic(testCase.lintCertBytes, testCase.leafCertBytes)
			if testCase.errorSubstr != "" {
				test.AssertError(t, err, "your lack of errors is disturbing")
				test.AssertContains(t, err.Error(), testCase.errorSubstr)
			} else {
				test.AssertNotError(t, err, "unexpected error")
			}
		})
	}
}
