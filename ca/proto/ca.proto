syntax = "proto3";

package ca;
option go_package = "github.com/letsencrypt/boulder/ca/proto";

import "core/proto/core.proto";
import "google/protobuf/timestamp.proto";

// CertificateAuthority issues certificates.
service CertificateAuthority {
  rpc IssuePrecertificate(IssueCertificateRequest) returns (IssuePrecertificateResponse) {}
  rpc IssueCertificateForPrecertificate(IssueCertificateForPrecertificateRequest) returns (core.Certificate) {}
}

// CertificateProfile contains a human readable profile name and a byte hash of
// the entire profile.
message CertificateProfile {
  // Next unused field number: 3

  // The name is guaranteed to be non-empty because a default name will be
  // assigned during *Profile construction if no name is provided.
  string name = 1;

  // The hash over the full contents of a certificate profile ensures that the
  // profile remains unchanged after multiple roundtrips through the RA and CA.
  bytes hash = 2;
}

message IssueCertificateRequest {
  // Next unused field number: 6
  bytes csr = 1;
  int64 registrationID = 2;
  int64 orderID = 3;
  int64 issuerNameID = 4;

  // The receiving CA must ensure the `name` field is found within its internal
  // map of certificate profiles or else a precertificate could be issued from
  // an unintended profile. The hash field will be empty at this point because
  // the RA is just routing the ACME client selected profile provided by the WFE
  // and has no internal understanding of a *Profile. 
  CertificateProfile certProfile = 5;
}

message IssuePrecertificateResponse {
  // Next unused field number: 3
  bytes DER = 1;
  // The CA will use the selected profile during issuance of the precertificate.
  // It must return a fully populated CertificateProfile message to the RA along
  // so that eventual issuance of the final certificate can be performed using
  // the same profile.
  CertificateProfile certProfile = 2;
}

message IssueCertificateForPrecertificateRequest {
  // Next unused field number: 6
  bytes DER = 1;
  repeated bytes SCTs = 2;
  int64 registrationID = 3;
  int64 orderID = 4;

  // The RA sends the fully populated CertificateProfile it previously received
  // back to a (possibly different) CA. The receiving CA must ensure the value
  // of the `hash` field is found within its internal map of certificate
  // profiles or else a certificate could be issued from a different profile
  // than the precertificate.
  CertificateProfile certProfile = 5;
}

// OCSPGenerator generates OCSP. We separate this out from
// CertificateAuthority so that we can restrict access to a different subset of
// hosts, so the hosts that need to request OCSP generation don't need to be
// able to request certificate issuance.
service OCSPGenerator {
  rpc GenerateOCSP(GenerateOCSPRequest) returns (OCSPResponse) {}
}

// Exactly one of certDER or [serial and issuerID] must be set.
message GenerateOCSPRequest {
  // Next unused field number: 8
  string status = 2;
  int32 reason = 3;
  reserved 4; // Previously revokedAtNS
  google.protobuf.Timestamp revokedAt = 7;
  string serial = 5;
  int64 issuerID = 6;
}

message OCSPResponse {
  bytes response = 1;
}

// CRLGenerator signs CRLs. It is separated for the same reason as OCSPGenerator.
service CRLGenerator {
  rpc GenerateCRL(stream GenerateCRLRequest) returns (stream GenerateCRLResponse) {}
}

message GenerateCRLRequest {
  oneof payload {
    CRLMetadata metadata = 1;
    core.CRLEntry entry = 2;
  }
}

message CRLMetadata {
  // Next unused field number: 5
  int64 issuerNameID = 1;
  reserved 2; // Previously thisUpdateNS
  google.protobuf.Timestamp thisUpdate = 4;
  int64 shardIdx = 3;
}

message GenerateCRLResponse {
  bytes chunk = 1;
}
